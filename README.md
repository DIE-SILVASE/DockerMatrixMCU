# üõ†Ô∏è Preparaci√≥n del Entorno MatrixMCU (para alumnos) 

¬°Bienvenid@! Aqu√≠ tienes todo lo necesario para dejar tu entorno de desarrollo listo para trabajar con **MatrixMCU** y **QEMU**, directamente desde Visual Studio Code usando contenedores Docker.

---

## üöÄ 1. ¬øQu√© hace esto?

Este proceso:

- Construye una imagen Docker personalizada con todas las herramientas (compilador ARM, QEMU, MatrixMCU...).
- Configura autom√°ticamente rutas, permisos y usuarios dentro del contenedor.
- Exporta la variable de entorno `MATRIXMCU` apuntando a la ra√≠z del framework.
- Permite compilar, debuggear y emular sin tocar la configuraci√≥n del sistema anfitri√≥n.

---

## üß™ 2. Requisitos previos

Aseg√∫rate de tener instalado en tu m√°quina:

- ‚úÖ [Docker](https://docs.docker.com/get-docker/)
- ‚úÖ [Visual Studio Code](https://code.visualstudio.com/)
- ‚úÖ La extensi√≥n **Dev Containers** en VSCode

---

## üß∞ 3. Clonar el repositorio

Abre una terminal y ejecuta:

```bash
git clone https://github.com/tu_usuario/DockerMatrixMCU.git
```

Opcionalmente:
```bash
git config --global core.autocrlf input
```
Esto evitar√° problemas con saltos de l√≠nea si trabajas en Windows.

---

## üß∞ 4. Construir el entorno (solo una vez)

### ü™Ñ PASO 1 ‚Äî Ejecutar la Task de Build

Desde la paleta de comandos de VSCode (`Ctrl+Shift+P > Tasks: Run Task`):

- üîπ `Build MatrixMCU Environment (Linux/macOS)`
- üîπ `Build MatrixMCU Environment (Windows-PowerShell)`

Esto:

- Detecta el sistema operativo y UID del host.
- Construye la imagen `matrixmcu-env`.
- Crea la red `lab_virtual_net` si no existe.
- Descarga las im√°genes necesarias del laboratorio.

---


## üß† 5. Abrir el DevContainer

Abre la carpeta `DockerMatrixMCU/` en VSCode y selecciona `Reopen in Container`.

Esto ejecutar√° autom√°ticamente algunos scripts de configuraci√≥n del entorno.

> _‚ÑπÔ∏è **Scripts de inicializaci√≥n dentro del contenedor:**_  
> _‚Ä¢ `post-create.sh` (solo la primera vez): detecta el usuario real dentro del contenedor, crea `/home/$usuario/MatrixMCU`, establece un enlace simb√≥lico hacia `/workspace/projects` y guarda la ruta efectiva en `/tmp/matrixmcu_path`._  
> _‚Ä¢ `postStartCommand` (cada vez que se abre el contenedor): a√±ade din√°micamente a `~/.bashrc` la ruta efectiva guardada en `/tmp/matrixmcu_path`:_  
>
> ```bash
> export MATRIXMCU=/home/ubuntu/MatrixMCU
> 
> o
> 
> export MATRIXMCU=/home/dev/MatrixMCU
> ```
> _Esto garantiza compatibilidad con Windows, Linux y macOS y permite que el sistema detecte autom√°ticamente la ruta al framework MatrixMCU._

### üß≠ Una vez dentro del DevContainer

Para trabajar en un proyecto espec√≠fico, abre una terminal e introduce:

```bash
cd projects/mi_proyecto
code .
```

Esto abrir√° el proyecto dentro del contenedor en una nueva ventana de VSCode, permiti√©ndote compilar, depurar y usar todas las tareas integradas.


---

## üß™ 6. Ejecutar MICROLAB

Tras haber construido el entorno e iniciado el DevContainer, puedes iniciar o detener el laboratorio virtual (servidor y frontend) utilizando los **Tasks** integrados de VSCode.

Estos tasks permiten:

- Levantar los contenedores necesarios (`rust-server`, `interfaz-grafica`)
- Conectar autom√°ticamente el DevContainer a la red `lab_virtual_net`
- Abrir la interfaz web en el navegador (`http://localhost:5173`)


### ‚ñ∂Ô∏è Iniciar MICROLAB

> ‚ÑπÔ∏è **Nota importante:**  
> Despu√©s del paso anterior (`Reopen in Container`), solo tendr√°s abierta la carpeta `DockerMatrixMCU/` *dentro del DevContainer*.  
> Para ejecutar los tasks generales como **"Iniciar MICROLAB"** o **"Parar MICROLAB"**, necesitas volver a abrir la carpeta ra√≠z del proyecto (`DockerMatrixMCU/`) desde fuera del contenedor.
>
> Puedes hacerlo con `Ctrl+K Ctrl+O` y seleccionando la carpeta original.  
> As√≠ tendr√°s **dos ventanas de VSCode abiertas**: una con el entorno del DevContainer (`DockerMatrixMCU/`) y otra con el proyecto local donde est√°n los tasks.

Selecciona uno de estos tasks seg√∫n tu sistema operativo:

- **Linux/macOS**: `Iniciar MICROLAB (Linux/Mac)`
- **Windows**: `Iniciar MICROLAB (Windows)`

Esto ejecutar√° el script correspondiente (`lab.sh` o `lab.ps1`), que:

1. Lanza el entorno con `docker-compose up -d`
2. Conecta autom√°ticamente el contenedor `matrixmcu-dev` a la red `lab_virtual_net`
3. Abre la interfaz del laboratorio en el navegador (`http://localhost:5173`)

üß† **IMPORTANTE:**  
Despu√©s de este paso, vuelve a tu DevContainer en VSCode y pulsa **"Run and Debug ‚Üí Microlab"** desde la pesta√±a lateral de depuraci√≥n.

Esto iniciar√° QEMU con la conexi√≥n al entorno activo. ¬°No lo olvides!

### üõë Parar MICROLAB

Selecciona el task correspondiente:

- **Linux/macOS**: `Parar MICROLAB (Linux/Mac)`
- **Windows**: `Parar MICROLAB (Windows)`

Esto ejecutar√° `docker-compose down` desde la carpeta `setup`.

---

## üîÅ Cambios en CMake

En tu `CMakeLists.txt`, MatrixMCU se detecta as√≠:

```cmake
IF(NOT DEFINED MATRIXMCU)
    SET(MATRIXMCU  $ENV{MATRIXMCU})
    MESSAGE(STATUS "MATRIXMCU path (env): ${MATRIXMCU}")
ENDIF()

INCLUDE(${MATRIXMCU}/CMakeLists.txt)
```

---

## üêû Cambios en `launch.json` (debug)

En lugar de rutas relativas, se usa `${env:MATRIXMCU}`:

```json
"serverpath": "${env:MATRIXMCU}/../qemu_new/build/qemu-system-arm",
"configFiles": ["${env:MATRIXMCU}/openocd/stm32f4x.cfg"],
"svdFile": "${env:MATRIXMCU}/svd/STM32F405RG.svd"
```

---

## üõ°Ô∏è Compatibilidad con UID y sistemas

### üîç ¬øPor qu√© importa el UID?

Cuando usamos contenedores Docker, los archivos del proyecto se montan desde el sistema anfitri√≥n (tu m√°quina) al contenedor.  
Para que el contenedor pueda **leer y escribir correctamente en esos archivos**, el usuario dentro del contenedor debe tener **el mismo UID (User ID)** que el del sistema anfitri√≥n.

Esto es importante porque, si el UID no coincide, el contenedor podr√≠a no tener permisos para editar, compilar o guardar archivos en las carpetas compartidas.

#### üß™ Ejemplo:

- En un sistema Linux real, el primer usuario suele tener UID `1000`, pero si ese UID ya est√° ocupado, el siguiente ser√° `1001`, `1002`, etc.
- El entorno detecta autom√°ticamente tu UID con `id -u` y crea un usuario con ese mismo UID dentro del contenedor (`dev:UID`).
- As√≠, los archivos montados siguen siendo accesibles y editables desde el contenedor sin problemas de permisos.

---

### ‚ö†Ô∏è ¬øY por qu√© no podemos hacer esto en Docker Desktop?

En **Docker Desktop** (Windows o macOS), los contenedores no se ejecutan directamente sobre tu sistema, sino dentro de una **m√°quina virtual Linux oculta**.

Esto implica que:

- El contenedor **no puede saber qui√©n eres t√∫ realmente** como usuario de Windows o macOS.
- No existe un UID/GID equivalente a tu cuenta local que se pueda detectar desde el contenedor.
- Aunque el contenedor cree un usuario con UID `1000`, **eso no significa nada real para el sistema host**.
- Todos los archivos montados desde Windows/macOS aparecer√°n como propiedad de `root` o de un UID simulado, y no se puede cambiar.

---

### ‚úÖ Soluci√≥n implementada por MatrixMCU

- En **Linux real**: se detecta el UID real (`id -u`) y se crea un usuario con ese UID en la imagen (`dev`), asegurando permisos correctos.
- En **Docker Desktop**: como no se puede detectar el UID real, el entorno usa un **usuario gen√©rico (`ubuntu`)** con permisos amplios y preconfigurados.
- Se conf√≠a en que Docker Desktop monte los vol√∫menes con permisos que permitan escribir (lo cual suele funcionar correctamente si no se fuerzan UIDs).

Adem√°s:

- La ruta real `/home/dev/MatrixMCU` o `/home/ubuntu/MatrixMCU` se detecta autom√°ticamente.
- La variable de entorno `$MATRIXMCU` se exporta de forma correcta en cada caso, sin intervenci√≥n manual.

```plaintext
+----------------------------+           +------------------------------+
|     Linux (UID 1000 libre) |           | Docker Desktop (UID en uso)  |
+----------------------------+           +------------------------------+
| Usuario: dev               |           | Usuario: ubuntu              |
| /home/dev/MatrixMCU        |           | /home/ubuntu/MatrixMCU       |
| ‚Üí Enlace: /workspace       |           | ‚Üí Enlace: /workspace         |
| ‚Üí $MATRIXMCU exportado     |           | ‚Üí $MATRIXMCU exportado       |
+----------------------------+           +------------------------------+
```


## ‚úÖ Resultado final

Con esta configuraci√≥n:

- MatrixMCU funciona en **cualquier sistema operativo**.
- Puedes compilar y debuggear con **QEMU** desde VSCode sin errores.
- No necesitas configurar nada manualmente despu√©s del primer uso.

---

## ‚öôÔ∏è Lista de Tasks disponibles

```jsonc
// üöß SOLO LA PRIMERA VEZ
"Build MatrixMCU Environment (Linux/macOS)"
"Build MatrixMCU Environment (Windows-PowerShell)"

// üîÅ Para iniciar el laboratorio
"Iniciar MICROLAB (Linux/Mac)"
"Iniciar MICROLAB (Windows)"

// üõë Para detener el laboratorio
"Parar MICROLAB (Linux/Mac)"
"Parar MICROLAB (Windows)"

// üßπ DevContainer
"Parar dev-container MatrixMCU"
"Eliminar dev-container MatrixMCU"
```

---

## üßº Opcional: detener el DevContainer manualmente

Si necesitas cerrar el entorno:

1. Abre la paleta (`Ctrl+Shift+P`)
2. Ejecuta `Dev Containers: Close Remote Connection`

Esto cierra el contenedor sin destruirlo. Puedes reabrirlo m√°s tarde con `Reopen in Container`.

Tambi√©n puedes usar los tasks desde fuera del contenedor:   
```jsonc
"Parar dev-container MatrixMCU"
"Eliminar dev-container MatrixMCU"
```

-----
## üõ†Ô∏è Run OpenOCD Task

# üîß Instalaci√≥n y uso de OpenOCD con DevContainer

---

## ü™ü Windows

### ‚úÖ 1. Descargar el binario de OpenOCD

1. Ve a: [https://github.com/openocd-org/openocd/releases/tag/v0.12.0](https://github.com/openocd-org/openocd/releases/tag/v0.12.0)
2. Descarga:
   ```
   openocd-v0.12.0-i686-w64-mingw32.tar.gz
   ```

---

### üì¶ 2. Extraer el contenido

1. Crea una carpeta, por ejemplo:
   ```
   C:\tools\openocd
   ```
2. Extrae el `.tar.gz` en esa carpeta.
3. Entra en:
   ```
   C:\tools\openocd\bin
   ```
4. Ejecuta una prueba:

```powershell
& 'C:\tools\openocd\bin\openocd.exe' --version
```

üîê Si aparece SmartScreen:
- Pulsa **M√°s informaci√≥n** ‚Üí **Ejecutar de todas formas**
- O ve a Propiedades del `.exe` ‚Üí marca **Desbloquear**

---

### üõ† 3. A√±adir al PATH del sistema

1. Busca `Variables de entorno` en el men√∫ de inicio.
2. Edita `Path` en **Variables del sistema**.
3. A√±ade esta ruta (o donde lo hayas guardado):
   ```
   C:\tools\openocd\bin
   ```
4. Guarda y **reinicia la terminal**.
5. Verifica:

```powershell
openocd --version
```

---

### üß≤ 4. Instalar driver ST-Link

1. Descarga desde ST:
   üëâ [https://www.st.com/en/development-tools/stsw-link009.html](https://www.st.com/en/development-tools/stsw-link009.html)
2. Instala el paquete (driver oficial ST-LINK).

---

### üß™ 5. Prueba desde el host (Windows)

Conecta la placa y ejecuta:

```powershell
openocd -f interface/stlink.cfg -f target/stm32f4x.cfg
```

üîß Si da error, mant√©n pulsado RESET al lanzarlo.

Tambi√©n puedes usar la task:
```
Run OpenOCD (Windows)
```

---

>**Depuraci√≥n desde DevContainer**
>En `launch.json`:
>
>```json
>"gdbTarget": "host.docker.internal:3333",
>"servertype": "external"
>```

---
## üçè macOS

### ‚úÖ 1. Instalar OpenOCD con Homebrew

```bash
brew update
brew install open-ocd
```

> ‚ö†Ô∏è Nota: El paquete se llama `open-ocd` con gui√≥n.

---

### ‚úÖ 2. Verificar instalaci√≥n

```bash
openocd --version
```

---

### ‚úÖ 3. Ejecutar con la placa conectada

```bash
openocd -f interface/stlink.cfg -f target/stm32f4x.cfg
```

> üîê En macOS no necesitas drivers, pero aseg√∫rate de permitir acceso USB en Configuraci√≥n del sistema > Seguridad y privacidad.

>**Depuraci√≥n desde DevContainer**
>En `launch.json`:
>
>```json
>"gdbTarget": "host.docker.internal:3333",
>"servertype": "external"
>```

---
## üêß Linux

### ‚úÖ 1. Instalar OpenOCD

```bash
sudo apt update
sudo apt install openocd
```

---

### ‚úÖ 2. Verificar instalaci√≥n

```bash
openocd --version
```

---

### ‚úÖ 3. Prueba con placa conectada

```bash
openocd -f interface/stlink.cfg -f target/stm32f4x.cfg
```

üîß Si falla, mant√©n pulsado RESET al lanzar.

---

# üêß Soporte Linux con IP externa (sin Docker Desktop)

## üéØ Objetivo
Conectar desde el DevContainer al OpenOCD en el host Linux **sin usar `host.docker.internal`**, ya que no existe en Linux.

---

## üß† Soluci√≥n automatizada

### Task en el host (Linux) para detectar IP y lanzar OpenOCD

```json
 {
			"label": "Recargar IP del Host (Linux)",
			"type": "shell",
			"command": "bash",
			"args": [
			  "-c",
			  "ip r get 1.1.1.1 | grep -oP 'src \\K[0-9.]+' > ./projects/.ip_host_openocd"
			],
			"problemMatcher": []
		  }
```

---

### En `devcontainer.json`:

```json
"postStartCommand": "if [ -f /workspaces/MatrixMCU/projects/.ip_host_openocd ]; then echo export OPENOCD_HOST_IP=$(cat /workspaces/MatrixMCU/projects/.ip_host_openocd) >> ~/.bashrc; fi"
```

---

### En `launch.json`:

```json
"gdbTarget": "${env:OPENOCD_HOST_IP}:3333"
```

---

## ‚úÖ Resultado

- IP detectada autom√°ticamente
- No necesitas tocar nada manualmente
- OpenOCD se lanza en el host y se comunica correctamente con GDB desde el DevContainer



## üß™üß™üß™**Uso b√°sico (FLUJO)**üß™üß™üß™
   - Conecta tu placa STM32 al USB. 

  > ***HOST***
  >
  > **SI est√°s en linux, es importante que en caso de no haberlo hecho antes de abrir el devcontainer, hagas la Task "Recargar IP del Host (Linux)". (y eliminar el devcontainer con la task)... (para que se recargue la variable d entorno OPENOCD_HOST_IP) Y luego habras el devcontainer** 

   - Ejecuta en PowerShell:
     ```powershell
     openocd -f interface/stlink.cfg -f target/stm32f4x.cfg
     ```
     o el task: Run OPENOCD
     
   - Ver√°s la salida de OpenOCD indicando que est√° ‚Äúlistening on port 3333‚Äù.
   
   <!-- Para que OpenOCD acceda al adaptador ST-Link, abre PowerShell o CMD **como Administrador**:
   ```powershell
   openocd -f interface/stlink.cfg -f target/stm32f4x.cfg
   ``` -->
  ***DEVCONTAINER***
  -Launch.json: "Clean and Debug (stm32f446re) (External OpenOCD)





### Preguntas frecuentes

- **¬øPuedo pararlo?**  
  S√≠: pulsa el bot√≥n ‚ñ† ‚ÄúTerminate Task‚Äù en el panel de Terminal o presiona Ctrl+C en esa terminal.

- **¬øLo hago una vez y ya?**  
  Mientras la task siga activa no necesitas relanzarla.

- **¬øC√≥mo funciona?**  
  Inicia OpenOCD en segundo plano escuchando en el puerto GDB (3333).  
  Tu DevContainer (VSCode) se conecta a ese puerto para depurar con Cortex-Debug.


---

¬°Listo! Tu entorno est√° preparado para trabajar con MatrixMCU üéâ
